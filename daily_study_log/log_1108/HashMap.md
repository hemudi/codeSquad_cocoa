## Array, Linked List의 단점
- 배열의 경우 내부 인덱스를 이용해 자료의 검색이 한번에 이루어져 빠른 검색 속도를 보이지만, 데이터의 삽입, 삭제 시 많은 데이터가 밀리거나 빈자리를 채우기 위한 처리에 많은 시간이 소요됨
- 연결리스트는 삽입, 삭제 시 인근 노드들의 참조값만 수정해줌으로써 빠른 처리가 가능하지만 중간 위치의 데이터를 삽입, 삭제할 경우 해당 노드를 찾기 위해 처음부터 순회 검색을 해야하기 때문에 데이터의 수가 많아질 수록 효율이 떨어짐

## Hash
- 키값에 산술적인 연산을 적용하여 항목이 저장될 위치, 즉 인덱스를 직접 계산하는 방식
- 자료의 삽입과 탐색은 탐색키를 배열의 인덱스로 생각하고 그를 이용해 단지 배열의 특정 요소를 읽거나 쓰면 되는 방식 => O(1)

## Hash Function
- 키값에서 항목의 위치를 계산하는 함수
- 입력된 탐색키를 해시 주소(Hash Address)로 변환

## Hash Table
- Hash Function 에 의해 계산된 위치에 레코드를 저장한 표
- M개의 버킷(Bucket) 으로 이루어지고 하나의 버킷은 여러개의 슬롯(Slot)으로 이루어짐
- 하나의 슬롯에 여러개의 레코드가 저장됨

## Collision
- 충돌
- 버킷의 수가 고정되어 있으므로 경우에 따라 서로 다른 키가 해시 함수에 의해 같은 주소로 계산되는 경우
- 동일한 해시 주소를 발생시키는 키들을 동의어(synonym) 라고 함

---

## Hash Function 구현 방법

### 좋은 해시 함수의 조건

1. 충돌이 적어야함
2. 해시 함수의 값이 해시 테이블의 주소 영역 내에서 고르게 분포
3. 계산이 빨라야 함.

### 제산 함수
- 가장 일반적인 방법
- 나머지 연산자 mode 를 사용하는 것
- 테이블의 크기가 M 일 때 탐색키 k에 대해 
    > h(k) = k mod M
- 이때 가능하면 해시 테이블의 크기 M 은 소수(prime number) 를 선택하여 K mod M 이 0 에서 M - 1 을 골고루 사용하는 값을 만들어내게 한다.

### 폴딩 함수
- 주로 탐색키가 해시 테이블의 크기보다 더 큰 정수일 경우에 사용
- 탐색키를 몇개의 부분으로 나누어 이를 더하거나 비트별로 XOR 같은 부울 연산
  - 나누는 방법
      1. 이동 폴딩
      2. 경계 폴딩

### 중간 제곱 함수
- 탐색키를 제곱한 뒤 중간의 몇 비트를 취해 해시 주소를 생성
- 제곱한 값의 중간 비트들은 대개 탐색키의 모든 문자들과 관련이 있음



